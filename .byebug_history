exit
@job
job.apiID
@jobApiId
exit
@jobApiId
job.apiID
job.id
exit
@user.jobs.length
@user.jobs
@user.joba
@exists
exit
@user.jobs.select {|x| x.title == "Technology Solutions Developer"}
@user.jobs.select {|x| x.apiID == @jobApiId}
@user.jobs.select {|x| x.apiID == @jobApiId}.length
@user.jobs.each {|x| x.apiID == 1}.length
@user.jobs.each {|x| x.apiID == @jobApiId}.length
@user.jobs.each {|x| x.apiID == @jobApiId}
@user.jobs.each {|x| x.apiId == @jobApiId}
@user.jobs.length
@user.jobs
@userId
@jobApiId
@exists
exit
@exists
exists
exit
@exists
exit
@exists
exit
@exists
exit
xitg
exit
@user
@location@user
exit
@location
params
exit
Changing in scope during development is nearly impossible
Progress on a project is difficult to measure while in the middle of a phase
Not good for projects where changes to what is to be delivered are expected or possible
Not good for long projects or ongoing projects
Not a good model for complex projects, not good for object oriented work
High amount of risk and uncertainty 
Working software is not produced until late in the cycle
- Little room for revision or second-guessing. Once testing begins itâ€™s hard to make changes to things developed in the early phases
The cons:
Process and results are all well-documented
Easy to arrange tasks
Stages are clearly defined
Easy to manage as the approach is completely technical and specific. Each phase has specific deliverables and a review process
Simple to understand and put into use
Everyone shares the same deadlines as each phase is focused upon until completed
Allows for splitting work among different departments
The pros:
- Pros and cons of Waterfall
@location
params
